# proof_assistants_and_logic

このページは、形式証明支援系（Coq / Lean など）と論理学の学習接続を整理するためのノートです。

「紙の上では分かったはずなのに、証明支援系だと進まない」という壁は、
論理の理解不足ではなく、**証明を細分化して明示する経験不足**で起こることが多いです。
本ノートでは、その橋渡しをします。

## この章で扱うこと
- 命題＝型対応（Curry-Howard対応）の最小イメージ
- 自然演繹とタクティクの対応関係
- 手計算の証明練習から機械検証へ移るときの手順

## 最初に知っておく考え方
- 命題は「証明対象の型」として扱える。
- 証明は「その型の値（プログラム）」を構成する行為に対応する。
- したがって、曖昧な「たぶん成り立つ」は通らず、1ステップずつ根拠が必要になる。

## 自然演繹との対応（ざっくり）
- `A → B` を示す: 仮定 `A` を置いて `B` を導く（intro系タクティク）
- `A ∧ B` を使う: 連言を分解して `A` と `B` を取り出す（destruct系）
- `A ∨ B` を示す: どちらか一方を示して場合分けの入口を作る（left/right）
- 背理法や否定: システムごとの古典公理の扱いを確認する

## 学習の進め方（初学者向け）
1. まず紙で短い証明を書く（3〜8行程度）。
2. 各行に「何を使ったか（前提・規則）」を明記する。
3. その行単位を、証明支援系の1コマンドに対応づける。
4. 失敗した箇所は、ゴールと仮定の差分を文章で説明してから再実行する。

## 典型的なつまずき
- ゴールを読まずにタクティクを試行錯誤して迷子になる。
- 「暗黙に使っていた推論」を機械側が補完してくれず停止する。
- 古典論理のつもりで進めたが、環境が直観主義ベースで詰まる。

## ミニ練習案
- `A -> A`
- `A ∧ B -> A`
- `(A -> B) -> (¬B -> ¬A)`

まずはこの3題を、紙の自然演繹と証明支援系で往復すると、
「何を証明しているか」が急に明確になります。

## ナビゲーション
- 親: [README.md](README.md)
- 兄弟:
  - [modal_logic_and_computation.md](modal_logic_and_computation.md)
  - [logic_and_database_queries.md](logic_and_database_queries.md)
